REF:
https://blog.csdn.net/weixin_38118016/article/details/90761111

## 1. 常见算法
### 1.1 二分搜索 **
    a. 查找指定值所在下标，
    b. 查找第一个大于某值的下标
### 1.2 DFS ***、BFS *
    a. DFS：回溯：LC.200 
    b. BFS：
### 1.3 DP 动态规划 *
    a. 状态转移方程
    b. 边界条件
    c. LC.63
### 1.4 滑动窗口 ***
    a. 滑动窗口的最大值，LC.239
### 1.5 双指针 ***
    

---------------------------------------------------------------------------------

## 2. 常见数据结构
### 2.1 Set **
    a. add()
    b. contains()
### 2.2 Map ***

### 2.3 List ***

### 2.4 Stack **
    a. 单调栈：LC.84

### 2.5 Tree **
    a. 各种二叉树
    b. 基础的搜索：前、中、后序遍历
    c. 独自建立特殊的树结构（比如节点带标记的大（小）顶堆
       特殊情况下还要实现树结构的增、删、查、改方法

---------------------------------------------------------------------------------

## 3. 常见技巧
### 3.1 二维坐标方位 **
    Tip.1
              N  E  S   W
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
    Tip.2
        或者合并为一个 dir = [0, 1, 0, -1, 0]
        for (int i = 0; i <=4; ++i) {
            // 0 -> 1 表示 N, E, S ,W
            nextRow = r + dir[i];
            nextCol = r + dir[i + 1];
        }
### 3.2 编码巧用 *
    合理使用编码，可以使得查询更加快速
    ex.
    见 LC.874
### 3.3 映射：元素不多时，Object[] arr = new Object[LEN] 代替Map（类似于2.3编码巧用） ***
    ex.
    LEN = 1000，Object = int时
    int[] map = new int[1000]
    使用时直接 map[idx]
### 3.5 算法时间复杂度估算
    a. 10^5方以下，可暴力O(n^2)
    b. 10^5 - 10^8次方，用O(nlog(n))
    c. 10^8左右，用O(n)
